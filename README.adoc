= Fun With Programming

== ABC - Always Be Coding
- Practice programming and keep your brain sharp

== Connect The Dots - Golang

[source, go]
----
fmt.Print("Anagrams relevant to encode & decode")
fmt.Print("Ana enD")
----

[source, go]
----
fmt.Print("2D Graph - graph [][]int")
fmt.Print("hasEdge:   graph[u][v] == 1")
----

[source, go]
----
fmt.Print("If BiPartite Graph")
fmt.Print("Then Red Blue Color Scheme @ Each Level")
fmt.Print("Visualize Graph as a Tree")
fmt.Print("If Node is Blue Then Its Neighbours in Red & Neighbours' Neighbours in Blue")
----

[source, go]
----
fmt.Print("BiPartite Color Store")
fmt.Print("colors []int - colors[u] = -1 or 0 or 1")
fmt.Print("-1=no_color, 0=red, 1=blue")
----

[source, go]
----
fmt.Print("Graph as 2D array vs. Adjacency List")
fmt.Print("Graph as 2D Array gives O(v^2) in BFS & other calculations")
fmt.Print("Graph as Adjacency List gives O(v+e) in BFS")
fmt.Print("Adjacency List == Sparse Graph == Space Efficient")
----

[source, go]
----
fmt.Print("When Array of strings Then 2D Array Already")
----

[source, go]
----
fmt.Print("When Alien Dictionary And Order of Chars is Given")

func OrderedAccess(order string) []int {
  var res = make([]int, 26)   // assume 26 is the max order
  for i, c := range order {
    res[c] = i                // notice the reverse store
  }
  return res
}
----

[source, go]
----
fmt.Print("When 'for loop' & use of '++' & lots of 'break' or 'continue'")
fmt.Print("Then better use 'for i:=0; i < size; i++' loop")
----

[source, go]
----
fmt.Println("Dependency calculations use Topological Sort")
fmt.Println("Dictionary")
fmt.Println("Compilation of dependent programs")

fmt.Println("A depends on B & B depends on C")
fmt.Println("Then in Topological Sort: [C, B, A]")
fmt.Println("Ulta Topi")
----

[source, go]
----
// ---
// EXTRA ELEMENTS CREEP IN; AVOID
// ---
var sarr = make([]int, len(arr))
for _, i := range arr {
  sarr = append(sarr, i)
}

// ---
// EXTRA ELEMENTS CREEP IN; AVOID
// ---
var sarr = make([]int, len(arr))
sarr = append(sarr, arr...)

// ---
// SIMPLE OLD STYLE COPY; GOOD
// ---
var sarr = make([]int, len(arr))
for idx, elem := range arr {
  sarr[idx] = elem
}
----

[source, go]
----
// Terse; Is It Safe?
func msort(given []int) []int {
  if len(given) == 1 {
    return given
  }

  mid := int(len(given)/2)
  left := given[0:mid]
  right := given[mid:]

  return merge(msort(left), msort(right))
}

// Vs.

// Verbose & Tricky But Perhaps Safer
func msort(given []int) []int {
  size := len(given)
  if size == 1 {
    return given
  }

  mid := int(size/2)
  var left = make([]int,mid)
  var right = make([]int,size-mid)    // WATCH OUT

  for idx, item := range given {
    if idx < mid {
      left[idx] = given[idx]
    } else {
      right[idx-mid] = given[idx]     // WATCH OUT
    }
  }

  return merge(msort(left), msort(right))
}
----

[source, go]
----
str[idx]        // bytes
rune(str[idx])  // rune
----

[source, go]
----
str[left:right+1] // SUBSTRING; LEFT & RIGHT INCLUDED
str[left:right]   // RIGHT EXCLUDED
----

[source, go]
----
// map[int]bool as seen
// map[rune]bool as seen

// TIP
// WHEN TO RESET
// RESET TO WHAT? 
// - EMPTY? 
// - SINGLE ELEMENT?
// - CURRENT ELEMENT?
----

[source, go]
----
// ^ IS NOT POWER
// ^ IS XOR
// ^ IS BITWISE XOR OPERATOR FOR INTEGERS
----

[source, go]
----
// rune is an alias for int32 
fmt.Println("RUINED INTERNATIONAL MAN")
----

[source, go]
----
// byte is an alias for unit8
fmt.Println("BYE TO UNIFY")
----

[source, go]
----
// unit ; all positive numbers including 0
// uint ranges from 0 to 4294967295
// int ranges from â€“2147483648 to 2147483647 
----

[source, go]
----
// MAX INT = HALF OF MAX UNIT
// MIN INT = -(HALF OF MAX UNIT) - 1

var MinUint uint = 0
var MaxUint uint = ^MinUint         // all ones

// Divide by 2 
// i.e. arithmetic right shift
var MaxInt int = int(MaxUint >> 1)  // all ones except high bit

// Either ^MaxInt 
// OR -MaxInt-1
var MinInt int = ^MaxInt            // all zeros except high bit

fmt.Println("TRY TO EAT BUFFET. YOU CAN'T. YOU END UP DIVIDING BY HALF")
fmt.Println("BUFFET EATS YOU. HE CAN. HIS MONEY GETS DOUBLED I.E. 2X")
----

[source, go]
----
// ARRAY MUTATION

size := len(arr)    // SOME ARRAY
top := arr[size-1]  // TOP IS LAST ELEMENT
arr = arr[:size-1]  // REMOVE LAST ELEM
----

[source, go]
----
// BST ITERATOR - O(h) space - h is tree's height

// STORE ROOT && THEN LEFT NODES(s) 
// I.E. STORE IN DESC ORDER
// IS ENOUGH TO PROVIDE ENTIRE TREE AS INORDER LIST
// NEXT() LOGIC IS TEASER

type BSTIter struct {
  Stack []*BST
}

func (i *BSTIter) push(b *BST) {
  tmp := b 
  for tmp != nil {
    // -------------------
    // Store in DESC order
    // -------------------
    i.Stack = append(i.Stack, tmp)
    tmp = tmp.Left // JUST THE LEFT
  }
}
----

[source, go]
----
// Product of Array Items Excluding Current

// --------
// HINT:
// --------
// - Loop 1 - L to R 
// - Product All Lefts i.e. Already Seen Items
// - Loop 2 - R to L
// - Product All Rights i.e. Already Seen Items

// - Use a New Array that Stores Above Product
// - Loop 1 - Arr[idx] = Current Left Product
// - Loop 2 - Arr[idx] = Arr[idx] * Current Right Product

// TIP - Product Excluding Self is Two loops Two Directions Solution
----

[source, go]
----
// Diameter of Binary Tree is all about maximums
// Having a maximum func helps a lot

func maximum(a, b int) int {
  if a > b {
    return a
  }
  return b
}
----

[source, go]
----
// MaxSumPath of BinaryTree is mad about max
// Avoid initialising to Min Int etc

func maximum(first int, others ...int) int {
  var max = first
  for _, i := range others {
    if max < i {
      max = i
    }
  }
  return max
}
----

== Algorithm & DataStructure References
==== https://github.com/aQuaYi/LeetCode-in-Go[AQuaYi's LeetCode In Go]
==== https://github.com/haoel/leetcode[Haoel's LeetCode]
==== https://github.com/de-cryptor/Must-Do-Coding-Questions[Must Do Coding Questions]
==== https://github.com/trekhleb/javascript-algorithms[Trekhleb's Javascript Algorithms]
==== https://github.com/mrekucci/epi/[Elements of Programming Interviews In Go]
==== https://github.com/adnanaziz/EPIJudge[Elements of Programming Interviews Judge]
==== https://fodor.org/blog/go-heap/[Fodor Go Blog]
==== https://github.com/dorin131/go-data-structures[Dorin131's Go Data Structures]

== System Design References
==== https://hackernoon.com/how-not-to-design-netflix-in-your-45-minute-system-design-interview-64953391a054[Hackernoon]
==== https://github.com/donnemartin/system-design-primer[Donnemartin's System Design Primer]
==== https://github.com/checkcheckzz/system-design-interview[Checkcheckzz's System Design Interview]
==== https://www.hiredintech.com/system-design[hiredintech]
==== https://www.interviewbit.com/courses/system-design[interviewbit]

== References
==== https://github.com/bbatsov/clojure-style-guide[clojure style guide] has inspired this styling

== People
==== https://github.com/trekhleb[trekhleb]
