= Fun With Programming

== Introduction

=== [Medium] Find the smallest lexicographical string from a given string & swap indices

==== Description
[source, bash]
----
The smallest lexicographical order is an order relation where string s
is smaller than t, given the first character of s (s1) is smaller than
the first character of t (t1), or in case they are equivalent, the 
second character, etc.
----

==== Samples
[source, bash]
----
Input: s = "dba", pairs = [[0,1],[1,2]]
Output: "abd"
Explanation:
Swap s[0] and s[1], s = "bda"
Swap s[1] and s[2], s = "bad"
Swap s[0] and s[1], s = "abd"
----

==== Source Code - Attempt 1 - WRONG !!!
[source, go]
----
type Pair struct {
  SrcIdx int
  DestIdx int
}

type PairList struct {
  Items []Pair
}

func toPairList(pairs [][]int) PairList {
  var list = &PairList{}
  for _, outer := range pairs {
    for src, dest := range outer {
      list.Items = append(
        list.Items,
        Pair{SrcIdx: src, DestIdx: dest},
      )
    }
  }
  return *list
}

func (p PairList) getDestIdxListBySrcIdx(index int) []int {
  var dests []int
  for _, item := range p.Items {
    if item.SrcIdx == index {
      dests = append(dests, item.DestIdx)
    }
  }
  return dests
}

func SmallestLexString(given string, swaps [][]int) string {
  if len(given) <= 1 return given
  
  swapPairs := toPairList(swaps)
  
  for idx, c := range given {
    eligibleSwaps := swappairs.getDestIdxListBySrcIdx(idx)
    for _, swpIdx := range eligibleSwaps {
      if c > given[swpIdx] {
        tmp = given[swpIdx]
        given[swpIdx] = c
        given[idx] = tmp
      }
    }
  }
  return given
}
----

=== [Easy] Delete Duplicates from a Sorted Slice of Ints

==== Samples
[source, bash]
----
Input: [1,1,2,3,3,4]
Result: [1,2,3,4,3,4] // we dont care the last two duplicates
Result: [1,2,3,4,0,0] // needs O(n^2) runtime

----

==== Source Code - Attempt 1
[source, go]
----
// O(1) space
// O(n^2) runtime - BAD

func DeleteDuplicates(sorted []int) []int {
  for j := len(sorted)-1; j > 0; j-- {
    if sorted[j] != sorted[j-1] {
      continue
    }
    tmp := j
    for tmp < len(sorted) {
      var rightVal
      if tmp+1 < len(sorted) {
        rightVal = sorted[tmp+1]
      }
      sorted[tmp]=rightVal
      tmp++
    }
  }
  return sorted
}
----

==== Source Code - Attempt 2 - WRONG !!!
[source, go]
----
func DeleteDuplicates(sorted []int) []int {
  for i := 0; i < len(sorted)-1; i++ {
    if sorted[i] != sorted[i+1] {
      continue
    }
    if i+2 <= len(sorted)-1 {
      sorted[i+1]=sorted[i+2]
    } else {
      sorted[i+1]=0
    }
  }
  return sorted
}
----

==== Source Code - Attempt 3
[source, go]
----
// O(n) space
// O(n) runtime - GOOD
// SLOW MOVING POINTER
// SLOW ++ WHEN CURRENT ITEM != NEXT ITEM

func DeleteDuplicates(sorted []int) []int {
  var slow = 1 // SLOW LOW starts from 1
  for i := 1; i < len(sorted); i++ { // i starts from 1 as well
    if sorted[i] != sorted[i-1] {
      sorted[slow] = sorted[i]
      slow++
    }
  }
  return sorted[:slow]
}
----


=== [Easy] Find if Each item has Unique number of Occurrences

==== Samples
[source, bash]
----
Input: arr = [1,3,2,1,1,3]
Output: true
Reason: 
- 1 is found 3 times, 
- 2 is found 1 time &
- 3 is found 2 times
----

==== Source Code - Attempt 1
[source, go]
----
// O(n) space
// O(n^2) runtime - BAD

func IsUniqueOccurrences(given []int) bool {
  if len(given) <= 1 return true

  // item to count mapping
  var times = map[int]int{}
  for _, item := range given {
    times[item] = times[item]++ // !!! WRONG !!!
  }
  for k, v := range times {
    for k1, v1 := range times {
      if k == k1 continue
      if v == v1 return false
    }
  }
  return true
}
----

==== Source Code - Attempt 2
[source, go]
----
// O(n) space
// O(n) runtime - GOOD

func IsUniqueOccurrences(given []int) bool {
  if len(given) <= 1 return true
  
  // map item to its freq
  var times = make(map[int]int, len(given))
  for _, item := range given {
    times[item]++ // !!! CORRECT !!!
  }

  if len(times) == 1 return true
  
  // map frequency to truth
  var seen = make(map[int]bool, len(times))
  for _, count := range times{
    if seen[count] return false
    seen[count] = true
  }
  return true
}
----

=== [Easy] Find Max number of Balanced Strings from a string having L & R chars

==== Samples
[source, bash]
----
Input: = "RLRRLLRLRL"
Output: 4
Reason: Input can be split into 
- "RL", 
- "RRLL", 
- "RL", 
- "RL", 
where each substring contains same number of 'L' and 'R'
----

==== Tips
[source,bash]
----
- Single counter does the trick
- EITHER 'Increment' OR 'Decrement' the counter
- Note logic is based around 2 chars 'L' & 'R'
----

==== Source Code - Attempt 1
[source, go]
----
func MaxBalStrings(given string) int {
  if len(given) <= 1 return 0

  var max int
  var lCount, rCount int
  for _, c := range given {
    if c == 'L' lCount++
    if c == 'R' rCount++
    if lCount == rCount {
      max++
      lCount=0 // reset
      rCount=0 // reset
    }
  }
  return max
}
----

==== Source Code - Attempt 2
[source,go]
----
func MaxBalStrings(given string) int {
  if len(given) <= 1 return 0
  var max, counter int
  for _, c := range given {
    if c == 'L' {
      counter++ // use of single counter
    }
    if c == 'R' {
      counter-- // R is used to decrement / reset
    }
    if counter == 0 max++
  }
  return max
}
----

=== [Easy] Find the Max Sum of a Contiguous Sequence

[source,bash]
----
Input - [1, -1, 0]
Result - 1

Input - [-1, -6, -5, 0]
Result - 0

Input - [1, 1, 1, -2, 4, 5]
Result - 10
----

==== Source Code
[source,go]
----
// NOTE: if contiguous then single loop logic

func MaxSum(given []int) int {
  if len(given) == 0 return 0 // !! SMART INIT !!
  if len(given) == 1 return given[0] // !! SMART INIT !!
  
  // !! NO NEED TO FIND MIN INT !!
  var maxSum = given[0] // !! SMART INIT AVOIDS COMPLEX CONDS LATER
  var currMax = 0

  for (i:=0;i<len(given)-1;i++) {
    currMax += given[i] // !! JUST ADD TO GET CURRENT SUM !!
    
    if maxSum < currMax { // !! SIMPLE LOGIC IF ALL ITEMS WERE +VE !!
      maxSum = currMax
    } else if currMax < 0 { // !! SPECIAL CASE FOR -VEs !! ELSE IF
      currMax = 0  // !! REMOVES TRICKY COMBINATIONS !!
    }
  }
  
  return maxSum
}
----

== References
- https://github.com/bbatsov/clojure-style-guide[clojure-style-guide] has inspired this styling
- https://github.com/mrekucci/epi/
- https://github.com/de-cryptor/Must-Do-Coding-Questions
- https://github.com/halfrost/LeetCode-Go
