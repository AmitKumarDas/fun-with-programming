= Fun With Programming

== Introduction
In this journey, I practice programming and keep my brain sharp.
I will try to put more common sense information that in turn lets the brain
frame the logic fast.

== Connect The Dots - Golang

[source, go]
----
// anagrams seem a lot like code/decode
----

[source, go]
----
// ---
// EXTRA ELEMENTS CREEP IN; AVOID
// ---
var sarr = make([]int, len(arr))
for _, i := range arr {
  sarr = append(sarr, i)
}

// ---
// EXTRA ELEMENTS CREEP IN; AVOID
// ---
var sarr = make([]int, len(arr))
sarr = append(sarr, arr...)

// ---
// SIMPLE OLD STYLE COPY; GOOD
// ---
var sarr = make([]int, len(arr))
for idx, elem := range arr {
  sarr[idx] = elem
}
----

[source, go]
----
// Terse; Is It Safe?
func msort(given []int) []int {
  if len(given) == 1 {
    return given
  }

  mid := int(len(given)/2)
  left := given[0:mid]
  right := given[mid:]

  return merge(msort(left), msort(right))
}

// Vs.

// Verbose & Tricky But Perhaps Safer
func msort(given []int) []int {
  size := len(given)
  if size == 1 {
    return given
  }

  mid := int(size/2)
  var left = make([]int,mid)
  var right = make([]int,size-mid)    // WATCH OUT

  for idx, item := range given {
    if idx < mid {
      left[idx] = given[idx]
    } else {
      right[idx-mid] = given[idx]     // WATCH OUT
    }
  }

  return merge(msort(left), msort(right))
}
----

[source, go]
----
str[idx]        // bytes
rune(str[idx])  // rune
----

[source, go]
----
str[left:right+1] // SUBSTRING; LEFT & RIGHT INCLUDED
str[left:right]   // RIGHT EXCLUDED
----

[source, go]
----
// map[int]bool as seen
// map[rune]bool as seen

// TIP
// WHEN TO RESET
// RESET TO WHAT? 
// - EMPTY? 
// - SINGLE ELEMENT?
// - CURRENT ELEMENT?
----

[source, go]
----
// ^ IS NOT POWER
// ^ IS XOR
// ^ IS BITWISE XOR OPERATOR FOR INTEGERS
----

[source, go]
----
// rune is an alias for int32 
fmt.Println("RUINED INTERNATIONAL MAN")
----

[source, go]
----
// byte is an alias for unit8
fmt.Println("BYE TO UNIFY")
----

[source, go]
----
// unit ; all positive numbers including 0
// uint ranges from 0 to 4294967295
// int ranges from â€“2147483648 to 2147483647 
----

[source, go]
----
// MAX INT = HALF OF MAX UNIT
// MIN INT = -(HALF OF MAX UNIT) - 1

var MinUint uint = 0
var MaxUint uint = ^MinUint         // all ones

// Divide by 2 
// i.e. arithmetic right shift
var MaxInt int = int(MaxUint >> 1)  // all ones except high bit

// Either ^MaxInt 
// OR -MaxInt-1
var MinInt int = ^MaxInt            // all zeros except high bit

fmt.Println("TRY TO EAT BUFFET. YOU CAN'T. YOU END UP DIVIDING BY HALF")
fmt.Println("BUFFET EATS YOU. HE CAN. HIS MONEY GETS DOUBLED I.E. 2X")
----

[source, go]
----
// ARRAY MUTATION

size := len(arr)    // SOME ARRAY
top := arr[size-1]  // TOP IS LAST ELEMENT
arr = arr[:size-1]  // REMOVE LAST ELEM
----

[source, go]
----
// BST ITERATOR - O(h) space - h is tree's height

// STORE ROOT && THEN LEFT NODES(s) 
// I.E. STORE IN DESC ORDER
// IS ENOUGH TO PROVIDE ENTIRE TREE AS INORDER LIST
// NEXT() LOGIC IS TEASER

type BSTIter struct {
  Stack []*BST
}

func (i *BSTIter) push(b *BST) {
  tmp := b 
  for tmp != nil {
    // -------------------
    // Store in DESC order
    // -------------------
    i.Stack = append(i.Stack, tmp)
    tmp = tmp.Left // JUST THE LEFT
  }
}
----

[source, go]
----
// Product of Array Items Excluding Current

// --------
// HINT:
// --------
// - Loop 1 - L to R 
// - Product All Lefts i.e. Already Seen Items
// - Loop 2 - R to L
// - Product All Rights i.e. Already Seen Items

// - Use a New Array that Stores Above Product
// - Loop 1 - Arr[idx] = Current Left Product
// - Loop 2 - Arr[idx] = Arr[idx] * Current Right Product

// TIP - Product Excluding Self is Two loops Two Directions Solution
----

[source, go]
----
// Diameter of Binary Tree is all about maximums
// Having a maximum func helps a lot

func maximum(a, b int) int {
  if a > b {
    return a
  }
  return b
}
----

[source, go]
----
// MaxSumPath of BinaryTree is mad about max
// Avoid initialising to Min Int etc

func maximum(first int, others ...int) int {
  var max = first
  for _, i := range others {
    if max < i {
      max = i
    }
  }
  return max
}
----

== References
==== https://github.com/bbatsov/clojure-style-guide[clojure style guide] has inspired this styling
==== https://github.com/aQuaYi/LeetCode-in-Go[AQuaYi's LeetCode In Go]
==== https://github.com/mrekucci/epi/[Elements of Programming Interviews In Go]
==== https://github.com/de-cryptor/Must-Do-Coding-Questions[Must Do Coding Questions]
==== https://github.com/haoel/leetcode[Haoel's LeetCode]
==== https://github.com/dorin131/go-data-structures[Dorin131's go data structures]
