= Programming meets story telling

== Introduction

== Easy

=== Find if Each item has Unique number of Occurrences

==== Samples
[source, bash]
----
Input: arr = [1,3,2,1,1,3]
Output: true
Reason: 
- 1 is found 3 times, 
- 2 is found 1 time &
- 3 is found 2 times
----

==== Source Code - Attempt 1
[source, go]
----
// O(n) space
// O(n^2) runtime

func IsUniqueOccurrences(given []int) bool {
  if len(given) <= 1 return true

  // item to count mapping
  var times = map[int]int{}
  for _, item := range given {
    times[item] = times[item]++
  }
  for k, v := range times {
    for k1, v1 := range times {
      if k == k1 continue
      if v == v1 return false
    }
  }
  return true
}
----

=== Find Max number of Balanced Strings from a string having L & R chars

==== Samples
[source, bash]
----
Input: = "RLRRLLRLRL"
Output: 4
Reason: Input can be split into 
- "RL", 
- "RRLL", 
- "RL", 
- "RL", 
where each substring contains same number of 'L' and 'R'
----

==== Tips
[source,bash]
----
- Single counter does the trick
- EITHER 'Increment' OR 'Decrement' the counter
- Note logic is based around 2 chars 'L' & 'R'
----

==== Source Code - Attempt 1
[source, go]
----
func MaxBalStrings(given string) int {
  if len(given) <= 1 return 0

  var max int
  var lCount, rCount int
  for _, c := range given {
    if c == 'L' lCount++
    if c == 'R' rCount++
    if lCount == rCount {
      max++
      lCount=0 // reset
      rCount=0 // reset
    }
  }
  return max
}
----

==== Source Code - Attempt 2
[source,go]
----
func MaxBalStrings(given string) int {
  if len(given) <= 1 return 0
  var max, counter int
  for _, c := range given {
    if c == 'L' {
      counter++ // use of single counter
    }
    if c == 'R' {
      counter-- // R is used to decrement / reset
    }
    if counter == 0 max++
  }
  return max
}
----

== Arrays can twist your brain
=== Find the Max Sum of a Contiguous Sequence

[source,bash]
----
Input - [1, -1, 0]
Result - 1

Input - [-1, -6, -5, 0]
Result - 0

Input - [1, 1, 1, -2, 4, 5]
Result - 10
----

==== How to solve in a single loop
[source, bash]
----
This talks about contiguous sequence. 
Imagine this like some kind of sort. 
Hopefully a single pass i.e O(N) is enough
----

==== When to include & when to avoid negatives
[source,bash]
----
Relax. 
Try solving the max sum part. 
Use the canonical Comparison & Swap logic FIRST to make a headstart.
----

==== Handling Multiple Combinations is Tricky
[source,bash]
----
Sum can grow as well as reduce. 
Who knows the next item will grow the sum further.
----

==== Is there any Trick?
[source,bash]
----
Consider two variables Max_SUM & Current_SUM

NOTE: Do not let the Current_SUM to be less than 0 @ a Special Condition
NOTE: This helps us manage many many combinations easily
----

==== Source Code
[source,go]
----
func MaxSum(given []int) int {
  if len(given) == 0 return 0
  if len(given) == 1 return given[0]
  
  // IMP - no need to init MIN INT
  var maxSum = given[0]
  var currMax = 0
  for (i:=0;i<len(given)-1;i++) {
    currMax += given[i]
    if maxSum < currMax {
      maxSum = currMax
    } else if currMax < 0 { // else if is VERY IMP
      currMax = 0
    }
  }
  return maxSum
}
----

== Inspirations
- https://github.com/bbatsov/clojure-style-guide[clojure-style-guide] has inspired this styling
