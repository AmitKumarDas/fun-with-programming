= Fun With Programming

== Introduction
In this journey, I practice programming and keep my brain sharp.
I will try to put more common sense information that in turn lets the brain
frame the logic fast.

== Connect The Dots - Golang

[source, go]
----
// anagrams seem a lot like code/decode
----

[source, go]
----
// str[idx] is bytes
// rune(str[idx]) is rune
----

[source, go]
----
// str[left:right+1] ; SUBSTRING; LEFT & RIGHT INCLUDED
// str[left:right] ; BASED ON SCENARIO; RIGHT EXCLUDED
----

[source, go]
----
// map[int]bool as seen
// map[rune]bool as seen

// TIP
// WHEN TO RESET
// RESET TO WHAT? 
// - EMPTY? 
// - SINGLE ELEMENT?
// - CURRENT ELEMENT?
----

[source, go]
----
// ^ IS NOT POWER
// ^ IS XOR
// ^ IS BITWISE XOR OPERATOR FOR INTEGERS
----

[source, go]
----
// rune is an alias for int32 
// TIP - RUINED INTERNATIONAL MAN
----

[source, go]
----
// byte is an alias for unit8
// TIP - BYE TO UNIFY
----

[source, go]
----
// unit ; all positive numbers including 0
// uint ranges from 0 to 4294967295  
// int ranges from â€“2147483648 to 2147483647 
----

[source, go]
----
// MAX INT = HALF OF MAX UNIT
// MIN INT = -(HALF OF MAX UNIT) - 1

var MinUint uint = 0

// all ones
var MaxUint uint = ^MinUint

// divide by 2 i.e. arithmetic right shift
// all ones except high bit
var MaxInt int = int(MaxUint >> 1)

// either ^MaxInt or -MaxInt-1
// all zeros except high bit
var MinInt int = ^MaxInt

// TIP - TRY TO EAT BUFFET. YOU CAN'T. YOU END UP DIVIDING BY HALF
// TIP - BUFFET EATS YOU. HE CAN. HIS MONEY GETS DOUBLED I.E. 2X
----

[source, go]
----
// ARRAY MUTATION

size := len(arr)    // SOME ARRAY
top := arr[size-1]  // TOP IS LAST ELEMENT
arr = arr[:size-1]  // REMOVE LAST ELEM
----

[source, go]
----
// BST ITERATOR - O(h) space - h is tree's height

// STORE ROOT && THEN LEFT NODES(s) 
// I.E. STORE IN DESC ORDER
// IS ENOUGH TO PROVIDE ENTIRE TREE AS INORDER LIST
// NEXT() LOGIC IS TEASER

type BSTIter struct {
  Stack []*BST
}

func (i *BSTIter) push(b *BST) {
  tmp := b 
  for tmp != nil {
    // -------------------
    // Store in DESC order
    // -------------------
    i.Stack = append(i.Stack, tmp)
    tmp = tmp.Left // JUST THE LEFT
  }
}
----

[source, go]
----
// Product of Array Items Excluding Current

// --------
// HINT:
// --------
// - Loop 1 - L to R 
// - Product All Lefts i.e. Already Seen Items
// - Loop 2 - R to L
// - Product All Rights i.e. Already Seen Items

// - Use a New Array that Stores Above Product
// - Loop 1 - Arr[idx] = Current Left Product
// - Loop 2 - Arr[idx] = Arr[idx] * Current Right Product

// TIP - Product Excluding Self is Two loops Two Directions Solution
----

[source, go]
----
// Diameter of Binary Tree is all about maximums
// Having a maximum func helps a lot

func maximum(a, b int) int {
  if a > b {
    return a
  }
  return b
}
----

[source, go]
----
// MaxSumPath of BinaryTree is mad about max
// Avoid initialising to Min Int etc

func maximum(first int, others ...int) int {
  var max = first
  for _, i := range others {
    if max < i {
      max = i
    }
  }
  return max
}
----

== References
==== https://github.com/bbatsov/clojure-style-guide[clojure style guide] has inspired this styling
==== https://github.com/aQuaYi/LeetCode-in-Go[AQuaYi's LeetCode In Go]
==== https://github.com/mrekucci/epi/[Elements of Programming Interviews In Go]
==== https://github.com/de-cryptor/Must-Do-Coding-Questions[Must Do Coding Questions]
==== https://github.com/halfrost/LeetCode-Go[Halfrost's LeetCode In Go]
==== https://github.com/haoel/leetcode[Haoel's LeetCode]
