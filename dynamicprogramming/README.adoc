== ABC - Always Be Coding

[source, go]
----
fmt.Print("Memoization & BottomsUp")

fmt.Print("                   All About Filling Memo[][]")
fmt.Print("                   if else-if else blocks")

fmt.Print("                   Init memo to [m+1][n+1]")
fmt.Print("                   All memo[0][j]s are inited to j")
fmt.Print("                   All memo[i][0]s are inited to i")

fmt.Print("                   Nested loops (0 to m) & (0 to n) inclusive")
fmt.Print("                   Str access only at [i-1] & [j-1]")

fmt.Print("                   cache[m][n] holds the answer")
----

[source, go]
----
// Given:             str1 & str2
// Find:              No of Min Operations to convert str1 to str2
// Assumptions:       Insert, Delete & Replace are valid operations

// O(mxn)       space
// O(mxn)       runtime
func MinOps(str1, str2 string) {
  m := len(str1)
  n := len(str2)
  
  if m == 0 {
    return n
  }
  if n == 0 {
    return m
  }
  
  var cache [][]int = make([][]int, m+1, n+1)
  
  var ops int
  for i:=0; i<=m; i++ {
    for j:=0; j<=n; j++ {
      if i == 0 {
        cache[0][j] = j
      } else if j == 0 {
        cache[i][0] = i
      } else if str1[i-1] == str2[j-1] {
        cache[i][j] = cache[i-1][j-1]
      } else {
        cache[i][j] = 1 + minimum(
          cache[i-1][j-1], // replace
          cache[i-1][j],   // delete
          cache[i][j-1],   // insert
        )
      }
    }
  }
  return cache[m][n]
}
----

[source, go]
----
fmt.Print("Memoization & BottomsUp & Space Optimization")

fmt.Print("                   Store Past Results Only")
fmt.Print("                   memo[2][m+1]")
fmt.Print("                   memo[i%2][j] or memo[(i-1)%2][j] etc.")

fmt.Print("                   abs((i%2)-1) same as (i-1)%2")
fmt.Print("                   use (i-1)%2 if i >= 1")

fmt.Print("                   All memo[0][j]s are inited to j")

fmt.Print("                   Nested loops (1 to n) & (0 to m) inclusive")
fmt.Print("                   memo[n%2][m] holds the answer")
----


[source, go]
----
// O(mxn) runtime
// O(m)   space

func MinOps(str1, str2 string) {
  m := len(str1)
  n := len(str2)
  
  if m == 0 {
    return n
  }
  if n == 0 {
    return m
  }

  // i - str2 & j - str1
  // store results of previous calculations only
  var cache [][]int = make([][]int, 2, m+1)

  // init is same as second string being empty
  for j:=0; j<=m; j++{
    cache[0][j] = j
  }

  var ops int
  for i:=1; i<=n; i++ {                 // str2
    for j:=0; j<=m; j++ {               // str1
      if j==0 {
        cache[i%2][0]=i
      } else if str1[j-1] == str2[i-1] {
        cache[i%2][j] = cache[(i-1)%2][j-1]
      } else {
        cache[i%2][j] = 1 + minimum(
          cache[(i-1)%2][j-1],          // REPLACE
          cache[(i-1)%2][j],            // DELETE
          cache[i%2][j-1],              // ADD
        )
      }
    }
  }
  return cache[n%2][m]
}
----
