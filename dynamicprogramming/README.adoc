== ABC - Always Be Coding

[source, go]
----
fmt.Print("Memoization & BottomsUp")

fmt.Print("                   All About Filling Memo[][]")
fmt.Print("                   if else-if else blocks")

fmt.Print("                   Init Cache to [m+1][n+1]")

fmt.Print("                   Nested Loops (0 to m) & (0 to n) Inclusive")
fmt.Print("                   Str access only at [i-1] & [j-1]")

fmt.Print("                   cache[m][n] holds the answer")
----

[source, go]
----
// Given:             str1 & str2
// Find:              No of Min Operations to convert str1 to str2
// Assumptions:       Insert, Delete & Replace are valid operations

// O(mxn)       space
// O(mxn)       runtime
func MinOps(str1, str2 string) {
  m := len(str1)
  n := len(str2)
  
  if m == 0 {
    return n
  }
  if n == 0 {
    return m
  }
  
  // ---
  // M+1 & N+1 FOR CACHE            WHY?
  //
  // - 0TH ROW                      i.e. EMPTY STR1
  // - 0TH COLUMN                   i.e. EMPTY STR2
  // ---
  var cache [][]int = make([][]int, m+1, n+1)
  
  var ops int
  for i:=0; i<=m; i++ {
    for j:=0; j<=n; j++ {
      if i == 0 {
        cache[0][j] = j
      } else if j == 0 {
        cache[i][0] = i
      } else if str1[i-1] == str2[j-1] {
        cache[i][j] = cache[i-1][j-1] ~ DIAGONAL
      } else {
        cache[i][j] = 1 + minimum(
          cache[i-1][j-1], // REPLACE ~ DIAGONAL
          cache[i-1][j],   // DELETE  ~ TOP
          cache[i][j-1],   // INSERT  ~ LEFT  
        )
      }
    }
  }
  return cache[m][n]
}
----

[source, go]
----
fmt.Print("Memoization & BottomsUp & Space Optimization")

fmt.Print("                   Store Past Results Only")
fmt.Print("                   memo[2][m+1]")
fmt.Print("                   memo[i%2][j] or memo[(i-1)%2][j] etc.")

fmt.Print("                   abs((i%2)-1) same as (i-1)%2")
fmt.Print("                   use (i-1)%2 if i >= 1")

fmt.Print("                   Nested loops (1 to n) & (0 to m) inclusive")
fmt.Print("                   memo[n%2][m] holds the answer")
----


[source, go]
----
// O(mxn) runtime
// O(m)   space

func MinOps(str1, str2 string) {
  m := len(str1)
  n := len(str2)
  
  if m == 0 {
    return n
  }
  if n == 0 {
    return m
  }

  // Store Results of Previous Calculations Only
  //
  // X=ROW      Y=COLUMN
  // X=TARGET   Y=GIVEN
  //
  // TWO ROWS & ALL GIVEN COLUMNS
  // VISUALIZE IN 2 ROWS
  //
  //   | 0 G I V E N
  //  -|-------------
  //  0|
  //  T|
  var cache [][]int = make([][]int, 2, m+1)

  // WHEN str2 is EMPTY
  for j:=0; j<=m; j++{
    cache[0][j] = j                     // VAL = j
  }

  var ops int
  for i:=1; i<=n; i++ {                 // str2
    for j:=0; j<=m; j++ {               // str1
      if j==0 {
        cache[i%2][0]=i                       // VAL = i & NOT i%2
      } else if str1[j-1] == str2[i-1] {
        cache[i%2][j] = cache[(i-1)%2][j-1]   // DIAGONAL
      } else {
        cache[i%2][j] = 1 + minimum(
          cache[(i-1)%2][j-1],          // REPLACE  ~ DIAGONAL
          cache[(i-1)%2][j],            // DELETE   ~ TOP
          cache[i%2][j-1],              // ADD      ~ LEFT
        )
      }
    }
  }
  return cache[n%2][m]
}
----
