## 2 Minutes Guide To eBPF

### 2 Programs Only
```yaml
- bpf program & userspace program
```

### Wny: libbpf
```yaml
- Used for LOADING a BPF program
- Used for INTERACTING with BPF program
- NOTE: libbpf library is imported into both bpf & userspace program
```

### Internals: libbpf & BPF program
```yaml
- BPF program uses HEADERS DEFINED in libbpf
- BPF program is COMPILED with clang to produce bpf OBJECT file
```

### Phases of a BPF program
```yaml
- Open Load Attachment Teardown
```

#### Open Phase
```yaml
- BPF object file is PARSED
- BPF maps, BPF programs, and GLOBAL variables are DISCOVERED, but NOT yet CREATED
- 
- After a BPF app is opened, it’s possible to make any additional adjustments 
- E.g setting BPF program types, if necessary; 
- E.g pre-setting initial values for global variables, etc
- Before all the entities are created and loaded
```

#### Load Phase
```yaml
- BPF maps are CREATED
- Various relocations are RESOLVED
- BPF programs are LOADED into the KERNEL and VERIFIED
- 
- At this point, all the parts of a BPF application are validated and EXIST in kernel
- But NO BPF program is EXECUTED
- 
- AFTER the load phase
- It’s possible to set up INITIAL BPF map STATE
- Without racing with the BPF program code execution
```

#### Attachment Phase
```yaml
- This is the phase at which BPF programs get attached to various BPF hook points 
- E.g., tracepoints, kprobes, cgroup hooks, network packet processing pipeline, etc.
- This is the phase at which BPF starts performing useful work
- It reads / updates BPF maps and global variables
```

#### Teardown Phase
```yaml
- BPF programs are DETACHED and UNLOADED from the kernel
- BPF maps are DESTROYED and all the RESOURCES used by the BPF app are FREED
```

### Example - 1
```c
SEC("tp/syscalls/sys_enter_write")
int handle_tp(void *ctx) {...}
```

```yaml
- Both the above lines together define the BPF program which will be loaded into the kernel
- It's represented as a normal C function in a specially named section (using SEC() macro)
- Section name defines WHAT type of BPF program libbpf should create 
- Section also tells HOW/WHERE it could be attached in the kernel
- In this case, we define a tracepoint BPF program
- This program will be called each time a write() syscall is invoked from ANY userspace program
```

### Example - 2
```c
bpf_printk("BPF triggered from PID %d.\n", pid);
```

```yaml
- This is a BPF equivalent of printf("Hello, world!\n")!
- It emits formatted string to the special file at /sys/kernel/debug/tracing/trace_pipe
- You can cat to see its contents from the console (make sure you use sudo or run under root)
- 
- bpf_printk() helper and trace_pipe file is not intended to be used in production
- But it's indispensable for debugging BPF code and getting insights into what your BPF program is doing
- As there is no BPF debugger yet, bpf_printk() is usually the fastest and most convenient way to debug a problem in a BPF code
```

### libbpf & userspace program
```yaml
- Userspace program uses libbpf to LOAD bpf OBJECT INTO kernel
- Userspace program uses libbpf to INTERACT with running bpf programs
```

### Userspace & Skeleton
```yaml
- Make a mental note of BPF skeleton of the BPF code
- This skeleton is generated by one of the Makefile targets
- This skeleton reflects the high level structure of the BPF program
```

#### Need for skeleton
```yaml
- Why? What is the need?
- It simplifies the deployment logistics
- It embeds the compiled BPF OBJECT code into the header file
- This header file is in turn included in the userspace code
- So no extra files to deploy along with the binary
- Just include the header & forget about it
```

#### Phases & Skeleton
```yaml
- <name>__open(): creates and opens BPF application
- <name>__load(): instantiates, loads, and verifies BPF application parts
- <name>__attach(): attaches all auto-attachable BPF programs
  - It’s optional, you can have more control by using libbpf APIs directly
- <name>__destroy(): detaches all BPF programs and frees up all used resources
```

### BPF maps and global variables 
```yaml
- They are shared between all BPF programs (allowing them to cooperate on a common set of data)
- BPF maps and global variables are also accessible from user-space
```

### Pro TIP - Coding Practice
```yaml
- A custom struct may be defined in common.h file
- This struct is included in bpf & userspace program
- Provides a way to transmit output to userspace everytime the bpf program is called
- You may set up a ring buffer for this
```

### Quirks &/ Notes
```yaml
- There could be MANY BPF programs defined within the same BPF C code file
- They could have DIFFERENT types (i.e., SEC() annotations)
-
- You can also define multiple BPF programs with the same SEC() attribute
- libbpf will handle the multiples just fine
- All BPF programs defined within the same BPF C code file share all the global state
- This is frequently utilized to coordinate few collaborating BPF programs
```

### Quirks - Does bpf program drops packets?
```yaml
- BPF_PROG_TYPE_SOCKET_FILTER
- Dropping packets if prog returns 0
- Trimming packets if returned length is less than original
```

```yaml
- We're NOT trimming or dropping the original packet
- Which would still reach the intended socket intact
- We're working with a COPY of the packet metadata
- Which RAW SOCKETS can access for observability
```

```yaml
- In addition to filtering packet flow to our socket
- We can do things that have side-effects
- e.g. collecting statistics in BPF maps
```

## References
```yaml
- https://nakryiko.com/posts/libbpf-bootstrap/
- https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/#bpf-skeleton-and-bpf-app-lifecycle
```
