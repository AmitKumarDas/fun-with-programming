### State of Performance Engineering 2021

### Golang
```yaml
- input and output is handled using std io.go

- I/O is buffered for efficiency
- use bufio.Scanner to read input
- use bufio.Writer to buffer output
```

### Golang - Fuzz Testing
```yaml
- https://blog.cloudflare.com/dns-parser-meet-go-fuzzer/
- RRDNS in-house DNS server
- uses github.com/miekgs/dns for all its parsing needs
- panicks on malformed packets

- this is Go, not C, and we can afford to recover() panics 
- no worrying about ending up with insane memory states
```

```go
func ParseDNSPacketSafely(buf []byte, msg *old.Msg) (err error) {
  defer func() {
    panicked := recover()
    if panicked != nil {
      err = errors.New("ParseError")
    }
  }()

  err = msg.Unpack(buf)
  return
}
```

### Golang - CPU Profile
```yaml
- https://go.dev/blog/pprof

- If Go testing.B is used
- we can use gotest’s standard -cpuprofile and -memprofile flags
- In a standalone program - import runtime/pprof
```

### Golang - Memory Profile
```yaml
- https://go.dev/blog/pprof

- If program is spending most of its time allocating memory and garbage collecting
- I.e. runtime.mallocgc - it allocates and runs periodic garbage collections 
- Add memory profiling to the program
```

```yaml
- use go tool pprof exactly the same way
- Now the samples we are examining are memory allocations, not clock ticks

- To reduce overhead
- Memory profiler only records information for approximately ONE BLOCK per HALF MEGABYTE allocated 
- i.e. “1-in-524288 sampling rate”
- So these are approximations to the actual counts
- To find the memory allocations - list those functions
```

```yaml
- If we run go tool pprof with the --inuse_objects flag
- it will report ALLOCATION COUNTS instead of SIZES

- Instead of using a map, we can use a simple slice to list the elements
- In all but one of the cases where maps are being used
- It is impossible for the algorithm to insert a duplicate element
- In the one remaining case, write a simple variant of the append
```

```go
func appendUnique(a []int, x int) []int {
  for _, y := range a {
    if x == y {
      return a
    }
  }
  return append(a, x)
}
```

```yaml
- Writing idiomatic Go style, using data structures and methods 
- Does not make your program slow
```

```yaml
- https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.go
- Idiomatic - Performant - Fellow
```

### Golang - Slice Better Than Map If You Can
```yaml
- Instead of map[*BasicBlock]int 
- use a []int
- a slice indexed by the block number
- no reason to use a map when an array or slice will do
```
```go
type BasicBlock struct {
  Name int // use this as the index of the slice
}
```

### Assembly | Compiler | Instructions | Interpreter
```yaml
- see the CPU instructions generated by the Go compiler
- need a disassembler 
- e.g. objdump which comes with the GNU binutils - may already be installed if Linux

- push instructions to add values onto the stack vs. placement onto the stack using mov
- performance - mov requires fewer CPU cycles than a push

- https://benhoyt.com/writings/goawk/
- awk interpreter in go

- https://blog.cloudflare.com/automatically-generated-types/
- workers - rust - typescript - intermediate representation
- abstract syntax tree
```

### Blogs
```yaml
- https://prometheus.io/blog/2019/10/10/remote-read-meets-streaming/
- https://github.com/google/cadvisor
- https://github.com/cloudflare/ebpf_exporter


- https://www.brendangregg.com/blog/2021-09-26/the-speed-of-time.html
- service restarting in loop // can be invisible in top(8)
```

### Tools
```yaml
- https://strace.io/
- attach to an already running process
```
